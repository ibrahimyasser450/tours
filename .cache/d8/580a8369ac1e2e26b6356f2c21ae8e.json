{"id":"../../node_modules/streamsearch/lib/sbmh.js","dependencies":[{"name":"C:\\Users\\Dell\\Downloads\\4-natours\\package.json","includedInParent":true,"mtime":1738438436952},{"name":"C:\\Users\\Dell\\Downloads\\4-natours\\node_modules\\streamsearch\\package.json","includedInParent":true,"mtime":1737809454670},{"name":"events","loc":{"line":5,"column":27,"index":179},"parent":"C:\\Users\\Dell\\Downloads\\4-natours\\node_modules\\streamsearch\\lib\\sbmh.js","resolved":"C:\\Users\\Dell\\Downloads\\4-natours\\node_modules\\events\\events.js"},{"name":"util","loc":{"line":6,"column":23,"index":226},"parent":"C:\\Users\\Dell\\Downloads\\4-natours\\node_modules\\streamsearch\\lib\\sbmh.js","resolved":"C:\\Users\\Dell\\Downloads\\4-natours\\node_modules\\util\\util.js"},{"name":"buffer","parent":"C:\\Users\\Dell\\Downloads\\4-natours\\node_modules\\streamsearch\\lib\\sbmh.js","resolved":"C:\\Users\\Dell\\Downloads\\4-natours\\node_modules\\buffer\\index.js"}],"generated":{"js":"var Buffer = require(\"buffer\").Buffer;\n/*\n  Based heavily on the Streaming Boyer-Moore-Horspool C++ implementation\n  by Hongli Lai at: https://github.com/FooBarWidget/boyer-moore-horspool\n*/\nvar EventEmitter = require('events').EventEmitter,\n  inherits = require('util').inherits;\nfunction jsmemcmp(buf1, pos1, buf2, pos2, num) {\n  for (var i = 0; i < num; ++i, ++pos1, ++pos2) if (buf1[pos1] !== buf2[pos2]) return false;\n  return true;\n}\nfunction SBMH(needle) {\n  if (typeof needle === 'string') needle = new Buffer(needle);\n  var i,\n    j,\n    needle_len = needle.length;\n  this.maxMatches = Infinity;\n  this.matches = 0;\n  this._occ = new Array(256);\n  this._lookbehind_size = 0;\n  this._needle = needle;\n  this._bufpos = 0;\n  this._lookbehind = new Buffer(needle_len);\n\n  // Initialize occurrence table.\n  for (j = 0; j < 256; ++j) this._occ[j] = needle_len;\n\n  // Populate occurrence table with analysis of the needle,\n  // ignoring last letter.\n  if (needle_len >= 1) {\n    for (i = 0; i < needle_len - 1; ++i) this._occ[needle[i]] = needle_len - 1 - i;\n  }\n}\ninherits(SBMH, EventEmitter);\nSBMH.prototype.reset = function () {\n  this._lookbehind_size = 0;\n  this.matches = 0;\n  this._bufpos = 0;\n};\nSBMH.prototype.push = function (chunk, pos) {\n  var r, chlen;\n  if (!Buffer.isBuffer(chunk)) chunk = new Buffer(chunk, 'binary');\n  chlen = chunk.length;\n  this._bufpos = pos || 0;\n  while (r !== chlen && this.matches < this.maxMatches) r = this._sbmh_feed(chunk);\n  return r;\n};\nSBMH.prototype._sbmh_feed = function (data) {\n  var len = data.length,\n    needle = this._needle,\n    needle_len = needle.length;\n\n  // Positive: points to a position in `data`\n  //           pos == 3 points to data[3]\n  // Negative: points to a position in the lookbehind buffer\n  //           pos == -2 points to lookbehind[lookbehind_size - 2]\n  var pos = -this._lookbehind_size,\n    last_needle_char = needle[needle_len - 1],\n    occ = this._occ,\n    lookbehind = this._lookbehind;\n  if (pos < 0) {\n    // Lookbehind buffer is not empty. Perform Boyer-Moore-Horspool\n    // search with character lookup code that considers both the\n    // lookbehind buffer and the current round's haystack data.\n    //\n    // Loop until\n    //   there is a match.\n    // or until\n    //   we've moved past the position that requires the\n    //   lookbehind buffer. In this case we switch to the\n    //   optimized loop.\n    // or until\n    //   the character to look at lies outside the haystack.\n    while (pos < 0 && pos <= len - needle_len) {\n      var ch = this._sbmh_lookup_char(data, pos + needle_len - 1);\n      if (ch === last_needle_char && this._sbmh_memcmp(data, pos, needle_len - 1)) {\n        this._lookbehind_size = 0;\n        ++this.matches;\n        if (pos > -this._lookbehind_size) this.emit('info', true, lookbehind, 0, this._lookbehind_size + pos);else this.emit('info', true);\n        this._bufpos = pos + needle_len;\n        return pos + needle_len;\n      } else pos += occ[ch];\n    }\n\n    // No match.\n\n    if (pos < 0) {\n      // There's too few data for Boyer-Moore-Horspool to run,\n      // so let's use a different algorithm to skip as much as\n      // we can.\n      // Forward pos until\n      //   the trailing part of lookbehind + data\n      //   looks like the beginning of the needle\n      // or until\n      //   pos == 0\n      while (pos < 0 && !this._sbmh_memcmp(data, pos, len - pos)) pos++;\n    }\n    if (pos >= 0) {\n      // Discard lookbehind buffer.\n      this.emit('info', false, lookbehind, 0, this._lookbehind_size);\n      this._lookbehind_size = 0;\n    } else {\n      // Cut off part of the lookbehind buffer that has\n      // been processed and append the entire haystack\n      // into it.\n      var bytesToCutOff = this._lookbehind_size + pos;\n      if (bytesToCutOff > 0) {\n        // The cut off data is guaranteed not to contain the needle.\n        this.emit('info', false, lookbehind, 0, bytesToCutOff);\n      }\n      lookbehind.copy(lookbehind, 0, bytesToCutOff, this._lookbehind_size - bytesToCutOff);\n      this._lookbehind_size -= bytesToCutOff;\n      data.copy(lookbehind, this._lookbehind_size);\n      this._lookbehind_size += len;\n      this._bufpos = len;\n      return len;\n    }\n  }\n  if (pos >= 0) pos += this._bufpos;\n\n  // Lookbehind buffer is now empty. Perform Boyer-Moore-Horspool\n  // search with optimized character lookup code that only considers\n  // the current round's haystack data.\n  while (pos <= len - needle_len) {\n    var ch = data[pos + needle_len - 1];\n    if (ch === last_needle_char && data[pos] === needle[0] && jsmemcmp(needle, 0, data, pos, needle_len - 1)) {\n      ++this.matches;\n      if (pos > 0) this.emit('info', true, data, this._bufpos, pos);else this.emit('info', true);\n      this._bufpos = pos + needle_len;\n      return pos + needle_len;\n    } else pos += occ[ch];\n  }\n\n  // There was no match. If there's trailing haystack data that we cannot\n  // match yet using the Boyer-Moore-Horspool algorithm (because the trailing\n  // data is less than the needle size) then match using a modified\n  // algorithm that starts matching from the beginning instead of the end.\n  // Whatever trailing data is left after running this algorithm is added to\n  // the lookbehind buffer.\n  if (pos < len) {\n    while (pos < len && (data[pos] !== needle[0] || !jsmemcmp(data, pos, needle, 0, len - pos))) {\n      ++pos;\n    }\n    if (pos < len) {\n      data.copy(lookbehind, 0, pos, pos + (len - pos));\n      this._lookbehind_size = len - pos;\n    }\n  }\n\n  // Everything until pos is guaranteed not to contain needle data.\n  if (pos > 0) this.emit('info', false, data, this._bufpos, pos < len ? pos : len);\n  this._bufpos = len;\n  return len;\n};\nSBMH.prototype._sbmh_lookup_char = function (data, pos) {\n  if (pos < 0) return this._lookbehind[this._lookbehind_size + pos];else return data[pos];\n};\nSBMH.prototype._sbmh_memcmp = function (data, pos, len) {\n  var i = 0;\n  while (i < len) {\n    if (this._sbmh_lookup_char(data, pos + i) === this._needle[i]) ++i;else return false;\n  }\n  return true;\n};\nmodule.exports = SBMH;"},"sourceMaps":null,"error":null,"hash":"1855a29833bd4dbea23a6880f7fadbc3","cacheData":{"env":{}}}