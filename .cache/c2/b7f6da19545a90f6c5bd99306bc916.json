{"id":"../../node_modules/dicer/lib/Dicer.js","dependencies":[{"name":"C:\\Users\\Dell\\Downloads\\4-natours\\package.json","includedInParent":true,"mtime":1738438436952},{"name":"C:\\Users\\Dell\\Downloads\\4-natours\\node_modules\\dicer\\package.json","includedInParent":true,"mtime":1737809454158},{"name":"stream","loc":{"line":1,"column":29,"index":29},"parent":"C:\\Users\\Dell\\Downloads\\4-natours\\node_modules\\dicer\\lib\\Dicer.js","resolved":"C:\\Users\\Dell\\Downloads\\4-natours\\node_modules\\stream-browserify\\index.js"},{"name":"readable-stream","loc":{"line":2,"column":32,"index":80},"parent":"C:\\Users\\Dell\\Downloads\\4-natours\\node_modules\\dicer\\lib\\Dicer.js","resolved":"C:\\Users\\Dell\\Downloads\\4-natours\\node_modules\\dicer\\node_modules\\readable-stream\\readable.js"},{"name":"util","loc":{"line":3,"column":23,"index":132},"parent":"C:\\Users\\Dell\\Downloads\\4-natours\\node_modules\\dicer\\lib\\Dicer.js","resolved":"C:\\Users\\Dell\\Downloads\\4-natours\\node_modules\\util\\util.js"},{"name":"streamsearch","loc":{"line":5,"column":27,"index":178},"parent":"C:\\Users\\Dell\\Downloads\\4-natours\\node_modules\\dicer\\lib\\Dicer.js","resolved":"C:\\Users\\Dell\\Downloads\\4-natours\\node_modules\\streamsearch\\lib\\sbmh.js"},{"name":"./PartStream","loc":{"line":7,"column":25,"index":221},"parent":"C:\\Users\\Dell\\Downloads\\4-natours\\node_modules\\dicer\\lib\\Dicer.js","resolved":"C:\\Users\\Dell\\Downloads\\4-natours\\node_modules\\dicer\\lib\\PartStream.js"},{"name":"./HeaderParser","loc":{"line":8,"column":27,"index":265},"parent":"C:\\Users\\Dell\\Downloads\\4-natours\\node_modules\\dicer\\lib\\Dicer.js","resolved":"C:\\Users\\Dell\\Downloads\\4-natours\\node_modules\\dicer\\lib\\HeaderParser.js"},{"name":"buffer","parent":"C:\\Users\\Dell\\Downloads\\4-natours\\node_modules\\dicer\\lib\\Dicer.js","resolved":"C:\\Users\\Dell\\Downloads\\4-natours\\node_modules\\buffer\\index.js"},{"name":"process","parent":"C:\\Users\\Dell\\Downloads\\4-natours\\node_modules\\dicer\\lib\\Dicer.js","resolved":"C:\\Users\\Dell\\Downloads\\4-natours\\node_modules\\process\\browser.js"}],"generated":{"js":"var Buffer = require(\"buffer\").Buffer;\nvar process = require(\"process\");\nvar WritableStream = require('stream').Writable || require('readable-stream').Writable,\n  inherits = require('util').inherits;\nvar StreamSearch = require('streamsearch');\nvar PartStream = require('./PartStream'),\n  HeaderParser = require('./HeaderParser');\nvar DASH = 45,\n  B_ONEDASH = new Buffer('-'),\n  B_CRLF = new Buffer('\\r\\n'),\n  EMPTY_FN = function () {};\nfunction Dicer(cfg) {\n  if (!(this instanceof Dicer)) return new Dicer(cfg);\n  WritableStream.call(this, cfg);\n  if (!cfg || !cfg.headerFirst && typeof cfg.boundary !== 'string') throw new TypeError('Boundary required');\n  if (typeof cfg.boundary === 'string') this.setBoundary(cfg.boundary);else this._bparser = undefined;\n  this._headerFirst = cfg.headerFirst;\n  var self = this;\n  this._dashes = 0;\n  this._parts = 0;\n  this._finished = false;\n  this._realFinish = false;\n  this._isPreamble = true;\n  this._justMatched = false;\n  this._firstWrite = true;\n  this._inHeader = true;\n  this._part = undefined;\n  this._cb = undefined;\n  this._ignoreData = false;\n  this._partOpts = typeof cfg.partHwm === 'number' ? {\n    highWaterMark: cfg.partHwm\n  } : {};\n  this._pause = false;\n  this._hparser = new HeaderParser(cfg);\n  this._hparser.on('header', function (header) {\n    self._inHeader = false;\n    self._part.emit('header', header);\n  });\n}\ninherits(Dicer, WritableStream);\nDicer.prototype.emit = function (ev) {\n  if (ev === 'finish' && !this._realFinish) {\n    if (!this._finished) {\n      var self = this;\n      process.nextTick(function () {\n        self.emit('error', new Error('Unexpected end of multipart data'));\n        if (self._part && !self._ignoreData) {\n          var type = self._isPreamble ? 'Preamble' : 'Part';\n          self._part.emit('error', new Error(type + ' terminated early due to unexpected end of multipart data'));\n          self._part.push(null);\n          process.nextTick(function () {\n            self._realFinish = true;\n            self.emit('finish');\n            self._realFinish = false;\n          });\n          return;\n        }\n        self._realFinish = true;\n        self.emit('finish');\n        self._realFinish = false;\n      });\n    }\n  } else WritableStream.prototype.emit.apply(this, arguments);\n};\nDicer.prototype._write = function (data, encoding, cb) {\n  // ignore unexpected data (e.g. extra trailer data after finished)\n  if (!this._hparser && !this._bparser) return cb();\n  if (this._headerFirst && this._isPreamble) {\n    if (!this._part) {\n      this._part = new PartStream(this._partOpts);\n      if (this._events.preamble) this.emit('preamble', this._part);else this._ignore();\n    }\n    var r = this._hparser.push(data);\n    if (!this._inHeader && r !== undefined && r < data.length) data = data.slice(r);else return cb();\n  }\n\n  // allows for \"easier\" testing\n  if (this._firstWrite) {\n    this._bparser.push(B_CRLF);\n    this._firstWrite = false;\n  }\n  this._bparser.push(data);\n  if (this._pause) this._cb = cb;else cb();\n};\nDicer.prototype.reset = function () {\n  this._part = undefined;\n  this._bparser = undefined;\n  this._hparser = undefined;\n};\nDicer.prototype.setBoundary = function (boundary) {\n  var self = this;\n  this._bparser = new StreamSearch('\\r\\n--' + boundary);\n  this._bparser.on('info', function (isMatch, data, start, end) {\n    self._oninfo(isMatch, data, start, end);\n  });\n};\nDicer.prototype._ignore = function () {\n  if (this._part && !this._ignoreData) {\n    this._ignoreData = true;\n    this._part.on('error', EMPTY_FN);\n    // we must perform some kind of read on the stream even though we are\n    // ignoring the data, otherwise node's Readable stream will not emit 'end'\n    // after pushing null to the stream\n    this._part.resume();\n  }\n};\nDicer.prototype._oninfo = function (isMatch, data, start, end) {\n  var buf,\n    self = this,\n    i = 0,\n    r,\n    ev,\n    shouldWriteMore = true;\n  if (!this._part && this._justMatched && data) {\n    while (this._dashes < 2 && start + i < end) {\n      if (data[start + i] === DASH) {\n        ++i;\n        ++this._dashes;\n      } else {\n        if (this._dashes) buf = B_ONEDASH;\n        this._dashes = 0;\n        break;\n      }\n    }\n    if (this._dashes === 2) {\n      if (start + i < end && this._events.trailer) this.emit('trailer', data.slice(start + i, end));\n      this.reset();\n      this._finished = true;\n      // no more parts will be added\n      if (self._parts === 0) {\n        self._realFinish = true;\n        self.emit('finish');\n        self._realFinish = false;\n      }\n    }\n    if (this._dashes) return;\n  }\n  if (this._justMatched) this._justMatched = false;\n  if (!this._part) {\n    this._part = new PartStream(this._partOpts);\n    this._part._read = function (n) {\n      self._unpause();\n    };\n    ev = this._isPreamble ? 'preamble' : 'part';\n    if (this._events[ev]) this.emit(ev, this._part);else this._ignore();\n    if (!this._isPreamble) this._inHeader = true;\n  }\n  if (data && start < end && !this._ignoreData) {\n    if (this._isPreamble || !this._inHeader) {\n      if (buf) shouldWriteMore = this._part.push(buf);\n      shouldWriteMore = this._part.push(data.slice(start, end));\n      if (!shouldWriteMore) this._pause = true;\n    } else if (!this._isPreamble && this._inHeader) {\n      if (buf) this._hparser.push(buf);\n      r = this._hparser.push(data.slice(start, end));\n      if (!this._inHeader && r !== undefined && r < end) this._oninfo(false, data, start + r, end);\n    }\n  }\n  if (isMatch) {\n    this._hparser.reset();\n    if (this._isPreamble) this._isPreamble = false;else {\n      ++this._parts;\n      this._part.on('end', function () {\n        if (--self._parts === 0) {\n          if (self._finished) {\n            self._realFinish = true;\n            self.emit('finish');\n            self._realFinish = false;\n          } else {\n            self._unpause();\n          }\n        }\n      });\n    }\n    this._part.push(null);\n    this._part = undefined;\n    this._ignoreData = false;\n    this._justMatched = true;\n    this._dashes = 0;\n  }\n};\nDicer.prototype._unpause = function () {\n  if (!this._pause) return;\n  this._pause = false;\n  if (this._cb) {\n    var cb = this._cb;\n    this._cb = undefined;\n    cb();\n  }\n};\nmodule.exports = Dicer;"},"sourceMaps":null,"error":null,"hash":"3294b4169379465ec5909c0d25156012","cacheData":{"env":{}}}